#!/bin/bash - 
#===============================================================================
#
#          FILE: passwd.sh
#
#         USAGE: ./passwd.sh 
#
#   DESCRIPTION: cgi script to modify unix passwords
#
#       OPTIONS: ---
#  REQUIREMENTS: sudo access to chpasswd
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: jecxjo (jeff@commentedcode.org)
#  ORGANIZATION:
#       CREATED: 09/20/15 13:28
#      REVISION: 0.0.3
#
#     CHANGELOG: 0.0.3 - Moved bash_cgi code to file
#                0.0.2 - Clean up
#                0.0.1 - Initial version
#===============================================================================


# Global Vars
URL="https://commentedcode.org/cgi-bin/passwd.sh"
TITLE="Change Password"
EMAIL_FROM_NAME="Webmaster"
EMAIL_FROM_ADDRESS="webmaster@commentedcode.org"
USER_DB="/var/lib/pwchange/users.db"
RESET_DB="/var/lib/pwchange/reset.db"
RND_CMD=$(dd if=/dev/random bs=1 count=32 | base64 | sed 's|+||g' | sed 's|/||g' | sed 's|=||g' | sed 's| ||g')

# Misc Functions
function Header() {
  echo "<head>"
  echo "  <title>${TITLE}</title>"
  echo "</head>"
}

#################
# Confirm Reset #
#################

# Apply new password and output HTML status
# 1->user, 2->pass
function ResetPass () {
  local usr="$1" pass="$2"
  # write new user:pass to system
  echo "${usr}:${pass}" | sudo chpasswd

  # Check if password change was successful
  if [ $? -eq 0 ]; then
    echo "<b>Success:</b> Password changed successfully<br />"

    # Remove all instances of reset keys
    local tmp=$(mktemp /tmp/reset.XXXXXX)
    sed "/:${usr}$/d" "${RESET_DB}" > "${tmp}"
    mv "${tmp}" "${RESET_DB}"
    chown http:http "${RESET_DB}"
    chmod 640 "${RESET_DB}"
  else
    echo "<b>Error:</b> Failed setting password<br />"
  fi
}

# Check if Key:User DB and return HTML Form to reset
# 1->user, 2->key
function ConfirmReset () {
  local usr="$1" key="$2"
  grep -q "^${key}:${usr}" "${RESET_DB}"

  # Check if reset code is valid
  if [ $? -eq 0 ]; then
    # Create form to enter new password
    echo "<b>User:</b> ${usr}<br/><b>Key:</b> ${key}<br />"
    echo "<h2>Reset Password</h2>"
    echo "<form action=\"${URL}\" method=\"POST\">"
    echo "  <input type=\"hidden\" name=\"cmd\" id=\"cmd\" value=\"resetpass\" />"
    echo "  <input type=\"hidden\" name=\"key\" id=\"key\" value=\"${key}\" />"
    echo "  <input type=\"hidden\" name=\"user\" id=\"user\" value=\"${usr}\" />"
    echo "  Password: <input type=\"password\" name=\"pass\" id=\"pass\" /><br />"
    echo "  Confirm: <input type=\"password\" name=\"passcfm\" id=\"passcfm\" /><br />"
    echo "  <input type=\"submit\" value=\"Submit\" />"
    echo "</form>"
  else
    echo "<b>Error:</b> Reset code is not valid<br />"
  fi
}

# Check if all form data is valid for new password on reset
# as generated by ConfirmReset
# 1->user, 2->key, 3->pass, 4->cfm
function ApplyNewPass () {
  local usr="$1" key="$2" pass="$3" cfm="$4"

  if [ -z "${usr}" ]; then
    echo "<b>Error:</b> No User entered<br />"
  elif [ -z "${key}" ]; then
    echo "<b>Error:</b> No Key<br />"
  elif [ -z "${pass}" ]; then
    echo "<b>Error:</b> No New Password<br />"
    ConfirmReset "${usr}" "${key}"
  elif [ -z "${cfm}" ]; then
    echo "<b>Error:</b> No New Password<br />"
    ConfirmReset "${usr}" "${key}"
  else
    grep -q "^${usr}:" /etc/passwd

    if [ $? -eq 1 ]; then
      echo "<b>Error:</b> User does not exist<br />"
    elif [ "${pass}" != "${cfm}" ]; then
      echo "<b>Error:</b> New Passwords don't match<br />"
      ConfirmReset "${usr}" "${key}"
    else
      ResetPass "${usr}" "${pass}"
    fi
  fi
}

##################
# Password Reset #
##################

# Find Email Address from Contact Info
# 1->user
function GetAddress () {
  local usr="$1"
  awk -v search="^${usr}:" '$0 ~ search{split($0,a,":"); print a[2];}' "${USER_DB}"
}

# Create form to request Reset Email
# 1->user
function UserResetForm () {
  local user=$1

  echo "<h2>Reset Password</h2>"
  echo "<form action=\"${URL}\" method=\"POST\">"
  echo "  <input type=\"hidden\" name=\"cmd\" id=\"cmd\" value=\"setreset\" />"
  echo "  User: <input type=\"text\" name=\"user\" id=\"user\" value=\"${user}\" /><br />"
  echo "  <input type=\"submit\" value=\"Submit\" />"
  echo "</form>"
}

# Create Email, send it and then generate HTML status
# 1->user
function ApplyReset () {
  local usr="$1"
  local key="${RND_CMD}"

  if [ -z "${usr}" ]; then
    echo "<b>Error:</b> No User entered<br />"
    UserResetForm ""
  else
    grep -q "^${usr}:" /etc/passwd

    if [ $? -eq 1 ]; then
      echo "<b>Error:</b> User does not exist<br />"
      UserResetForm ""
    else
      grep -q "^${usr}:" "${USER_DB}"

      if [ $? -eq 1 ]; then
        echo "<b>Error:</b> User has no contact info<br />"
        UserResetForm ""
      else
        # Create Email message
        local subject="Password Reset"
        local link="${URL}?cmd=cfmreset&user=${usr}&key=${key}"
        local address=$(GetAddress "${usr}")
        local message=$(cat <<EOF
A request was made to reset the password for ${usr}. If this was in error
please ignore this message. Otherwise follow the link to reset your account
password:

${link}

Thank you
EOF)
        local mail="subject:${subject}\nfrom:${EMAIL_FROM_ADDRESS}\n\n${message}"

        echo -e "${mail}" | sendmail -F "${EMAIL_FROM_NAME}" -f "${EMAIL_FROM_ADDRESS}" "${address}"

        if [ $? -eq 0 ]; then
          echo "<b>Success:</b> Email sent<br />"
          # Write key to database
          echo "${key}:${usr}" >> "${RESET_DB}"
        else
          echo "<b>Error:</b> Failed sending email<br />"
        fi
      fi
    fi
  fi
}

################
# Set Password #
################

# Create form to change password
# 1->user 2->old_pass
function UserPassForm () {
  local user=$1
  local old_pass=$2

  echo "<h2>Change Password</h2>"
  echo "<form action=\"${URL}\" method=\"POST\">"
  echo "  <input type=\"hidden\" name=\"cmd\" id=\"cmd\" value=\"setpass\" />"
  echo "  User: <input type=\"text\" name=\"user\" id=\"user\" value=\"${user}\" /><br />"
  echo "  Old Password: <input type=\"password\" name=\"oldpass\" id=\"oldpass\" value=\"${old_pass}\" /><br />"
  echo "  New Password: <input type=\"password\" name=\"pass\" id=\"pass\" /><br />"
  echo "  Confirm Password: <input type=\"password\" name=\"passcfm\" id=\"passcfm\" /><br />"
  echo "  <input type=\"submit\" value=\"Submit\" />"
  echo "</form>"
}

# Apply new password to user and generate HTML status
# 1->user, 2->old pass, 3->new pass
function SetPass () {
  local user=$1 pass=$2 new=$3

  out=$(expect -c '
    set timeout 10
    spawn su -c passwd - '"${user}"'
    expect "Password:" { send '\""${pass}\r\""' }
    expect "current) UNIX password:" { send '"\"${pass}\r\""' }
    expect "new UNIX password:" { send '"\"${new}\r\""' }
    expect "new UNIX password:" { send '"\"${new}\r\""' }
    expect {
      "successfully" { exit 0 }
      default { exit 1 }
    }')

  echo "${out}" | grep -q "successfully"

  if [ $? -eq 0 ]; then
    echo "<b>Success:</b> Password Changed<br />"
  else
    echo "<b>Error:</b> Failed changing password<br />"
  fi
}

# Validate form data generated by UserPassForm
# 1->user, 2->old, 3->newa, 4->newb
function ApplyPass () {
  local usr="$1"
  local old="$2"
  local newa="$3"
  local newb="$4"

  if [ -z "${usr}" ]; then
    echo "<b>Error:</b> No User entered<br />"
    UserPassForm "" ""
  elif [ -z "${old}" ]; then
    echo "<b>Error:</b> No Old Password<br />"
    UserPassForm "${usr}" ""
  elif [ -z "${newa}" ]; then
    echo "<b>Error:</b> No New Password<br />"
    UserPassForm "${usr}" "${old}"
  elif [ -z "${newb}" ]; then
    echo "<b>Error:</b> No New Password<br />"
    UserPassForm "${usr}" "${old}"
  else
    grep -q "^${usr}:" /etc/passwd

    if [ $? -eq 1 ]; then
      echo "<b>Error:</b> User does not exist<br />"
      UserPassForm "" ""
    elif [ "${newa}" != "${newb}" ]; then
      echo "<b>Error:</b> New Passwords don't match<br />"
      UserPassForm "${usr}" "${old}"
    else
      SetPass "${usr}" "${old}" "${newa}"
    fi
  fi
}

################
# Contact Info #
################

# Create form to update Contact Info
# 1->user, 2->email
function UserContactForm () {
  local user=$1
  local email=$2

  echo "<h2>Change Contact Info</h2>"
  echo "<form action=\"${URL}\" method=\"POST\">"
  echo "  <input type=\"hidden\" name=\"cmd\" id=\"cmd\" value=\"setcontact\" />"
  echo "  User: <input type=\"text\" name=\"user\" id=\"user\" value=\"${user}\" /><br />"
  echo "  Password: <input type=\"password\" name=\"pass\" id=\"pass\"  /><br />"
  echo "  Email: <input type=\"email\" name=\"email\" id=\"email\" value=\"${email}\" /><br />"
  echo "  <input type=\"submit\" value=\"Submit\" />"
  echo "</form>"
}

# Apply new contact info and generate HTML status
# 1->user, 2->password, 3->email
function SetContact () {
  local usr=$1 pass=$2 email=$3

  local f="/tmp/${usr}"

  local str="${usr}:${email}"

  # Touch file as user, requires correct password
  local out=$(expect -c '
    set timeout 10
    spawn -noecho su -c "touch '"${f}"'" - '"${usr}"'
    expect "Password:" { send '\""${pass}\r\""' }
    expect eof
    catch wait result
    exit [lindex $result 3]')

  # if su worked, user/pass was valid
  if [ -e "${f}" ]; then
    # Remove old contact info and add new
    TMP=$(mktemp /tmp/contact.XXXXXX)
    sed "/^${usr}:/d" "${USER_DB}" > "${TMP}"
    echo "${usr}:${email}" >> "${TMP}"
    mv "${TMP}" "${USER_DB}"
    chown http:http "${USER_DB}"
    chmod 640 "${USER_DB}"
    echo "<b>Success:</b> Contact Info Updated<br />"

    # cleanup touched file
    local out=$(expect -c '
      set timeout 10
      spawn -noecho su -c "rm '"${f}"'" - '"${usr}"'
      expect "Password:" { send '\""${pass}\r\""' }
      expect eof
      catch wait result
      exit [lindex $result 3]')
  else
    echo "<b>Error:</b> Failed to update DB, No file[${f}]<br />"
  fi
}

# Validate form data generated by UserContactForm
# 1->user, 2->pass, 3->email
function ApplyContact () {
  local usr="$1" pass="$2" email="$3"

  if [ -z "${usr}" ]; then
    echo "<b>Error:</b> No User entered<br />"
    UserContactForm "" "${email}"
  elif [ -z "${pass}" ]; then
    echo "<b>Error:</b> No Password<br />"
    UserContactForm "${usr}" "${email}"
  elif [ -z "${email}" ]; then
    echo "<b>Error:</b> No Email<br />"
    UserContactForm "${usr}" ""
  else
    grep -q "^${usr}:" /etc/passwd

    if [ $? -eq 1 ]; then
      echo "<b>Error:</b> User does not exist<br />"
      UserContactForm "" "${email}"
    else
      SetContact "${usr}" "${pass}" "${email}"
    fi
  fi
}

####################
# Main Application #
####################

# Switch on URL argument "cmd" to generate correct page
# $1->cmd
function Body () {
  echo "<body>"

  case "$1" in
    resetpass)
      ApplyNewPass "${user}" "${key}" "${pass}" "${passcfm}"
      ;;
    cfmreset)
      ConfirmReset "${user}" "${key}"
      ;;
    setreset)
      ApplyReset "${user}"
      ;;
    setpass)
      ApplyPass "${user}" "${oldpass}" "${pass}" "${passcfm}"
      ;;
    setcontact)
      ApplyContact "${user}" "${pass}" "${email}"
      ;;
    resetform)
      UserResetForm "${user}"
      ;;
    contactform)
      UserContactForm "${user}" "${email}"
      ;;
    passform)
      UserPassForm "${user}" "${oldpass}"
      ;;
    *)
      UserPassForm "${user}" "${oldpass}"
      ;;
  esac

  echo "<br />"
  echo "<a href=\"/cgi-bin/passwd.sh?cmd=passform\">Password</a>"
  echo "<a href=\"/cgi-bin/passwd.sh?cmd=contactform\">Contact</a>"
  echo "<a href=\"/cgi-bin/passwd.sh?cmd=resetform\">Reset Password</a>"

  echo "</body>"
}

# START bash_cgi
# Created by Philippe Kehl
# http://oinkzwurgl.org/bash_cgi
# (internal) routine to store POST data
function cgi_get_POST_vars()
{
  # check content type
  # FIXME: not sure if we could handle uploads with this..
  [ "${CONTENT_TYPE}" != "application/x-www-form-urlencoded" ] && \
    echo "bash.cgi warning: you should probably use MIME type "\
    "application/x-www-form-urlencoded!" 1>&2
  # save POST variables (only first time this is called)
  [ -z "$QUERY_STRING_POST" \
    -a "$REQUEST_METHOD" = "POST" -a ! -z "$CONTENT_LENGTH" ] && \
    read -n $CONTENT_LENGTH QUERY_STRING_POST
  # prevent shell execution
  local t
  t=${QUERY_STRING_POST//%60//} # %60 = `
  t=${t//\`//}
  t=${t//\$(//}
  t=${t//%24%28//} # %24 = $, %28 = (
  QUERY_STRING_POST=${t}
  return
}

# (internal) routine to decode urlencoded strings
function cgi_decodevar()
{
  [ $# -ne 1 ] && return
  local v t h
  # replace all + with whitespace and append %%
  t="${1//+/ }%%"
  while [ ${#t} -gt 0 -a "${t}" != "%" ]; do
    v="${v}${t%%\%*}" # digest up to the first %
    t="${t#*%}"       # remove digested part
    # decode if there is anything to decode and if not at end of string
    if [ ${#t} -gt 0 -a "${t}" != "%" ]; then
      h=${t:0:2} # save first two chars
      t="${t:2}" # remove these
      v="${v}"`echo -e \\\\x${h}` # convert hex to special char
    fi
  done
  # return decoded string
  echo "${v}"
  return
}

# routine to get variables from http requests
# usage: cgi_getvars method varname1 [.. varnameN]
# method is either GET or POST or BOTH
# the magic varible name ALL gets everything
function cgi_getvars()
{
  [ $# -lt 2 ] && return
  local q p k v s
  # prevent shell execution
  t=${QUERY_STRING//%60//} # %60 = `
  t=${t//\`//}
  t=${t//\$(//}
  t=${t//%24%28//} # %24 = $, %28 = (
  QUERY_STRING=${t}
  # get query
  case $1 in
    GET)
      [ ! -z "${QUERY_STRING}" ] && q="${QUERY_STRING}&"
      ;;
    POST)
      cgi_get_POST_vars
      [ ! -z "${QUERY_STRING_POST}" ] && q="${QUERY_STRING_POST}&"
      ;;
    BOTH)
      [ ! -z "${QUERY_STRING}" ] && q="${QUERY_STRING}&"
      cgi_get_POST_vars
      [ ! -z "${QUERY_STRING_POST}" ] && q="${q}${QUERY_STRING_POST}&"
      ;;
  esac
  shift
  s=" $* "
  # parse the query data
  while [ ! -z "$q" ]; do
    p="${q%%&*}"  # get first part of query string
    k="${p%%=*}"  # get the key (variable name) from it
    v="${p#*=}"   # get the value from it
    q="${q#$p&*}" # strip first part from query string
    # decode and evaluate var if requested
    [ "$1" = "ALL" -o "${s/ $k /}" != "$s" ] && \
      eval "$k=\"`cgi_decodevar \"$v\"`\""
  done
  return
}

cgi_getvars BOTH ALL
# END of bash_cgi

###################
# HTML Generation #
###################
echo Content-type: text/html
echo ""

echo "<!DOCTYPE html>"
echo "<html>"
Header
Body "${cmd}"
echo "</html>"

